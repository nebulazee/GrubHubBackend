{
  "_args": [
    [
      {
        "raw": "minipass@^2.3.5",
        "scope": null,
        "escapedName": "minipass",
        "name": "minipass",
        "rawSpec": "^2.3.5",
        "spec": ">=2.3.5 <3.0.0",
        "type": "range"
      },
      "D:\\React\\GrubHub\\GrubHubBackend\\node_modules\\tar"
    ]
  ],
  "_from": "minipass@^2.3.5",
  "_hasShrinkwrap": false,
  "_id": "minipass@2.6.0",
  "_location": "/minipass",
  "_nodeVersion": "12.8.1",
  "_npmOperationalInternal": {
    "host": "s3://npm-registry-packages",
    "tmp": "tmp/minipass_2.6.0_1568614365824_0.06329190526617268"
  },
  "_npmUser": {
    "name": "isaacs",
    "email": "i@izs.me"
  },
  "_npmVersion": "6.11.3",
  "_phantomChildren": {},
  "_requested": {
    "raw": "minipass@^2.3.5",
    "scope": null,
    "escapedName": "minipass",
    "name": "minipass",
    "rawSpec": "^2.3.5",
    "spec": ">=2.3.5 <3.0.0",
    "type": "range"
  },
  "_requiredBy": [
    "/fs-minipass",
    "/minizlib",
    "/tar"
  ],
  "_resolved": "https://registry.npmjs.org/minipass/-/minipass-2.6.0.tgz",
  "_shasum": "80a68c8a43257b7f744ce09733f6a9c6eef9f731",
  "_shrinkwrap": null,
  "_spec": "minipass@^2.3.5",
  "_where": "D:\\React\\GrubHub\\GrubHubBackend\\node_modules\\tar",
  "author": {
    "name": "Isaac Z. Schlueter",
    "email": "i@izs.me",
    "url": "http://blog.izs.me/"
  },
  "bugs": {
    "url": "https://github.com/isaacs/minipass/issues"
  },
  "dependencies": {
    "safe-buffer": "^5.1.2",
    "yallist": "^3.0.0"
  },
  "description": "minimal implementation of a PassThrough stream",
  "devDependencies": {
    "end-of-stream": "^1.4.0",
    "tap": "^14.6.1",
    "through2": "^2.0.3"
  },
  "directories": {},
  "dist": {
    "integrity": "sha512-OuNZ0OHrrI+jswzmgivYBZ+fAAGHZA4293d5q0z631/I9QSw3yumKB92njxHIHiB1eAdGRsE+3CcOPkoEyV5FQ==",
    "shasum": "80a68c8a43257b7f744ce09733f6a9c6eef9f731",
    "tarball": "https://registry.npmjs.org/minipass/-/minipass-2.6.0.tgz",
    "fileCount": 4,
    "unpackedSize": 17587,
    "npm-signature": "-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v3.0.4\r\nComment: https://openpgpjs.org\r\n\r\nwsFcBAEBCAAQBQJdfyfeCRA9TVsSAnZWagAAbEUP/1Cz0gDRJL4EEzhfQhdi\nq4eH3s5/Qumg41PBZhakzdYQIkPcjo9pb5Lhz9VWQ5cYwtFExoXM61JqmM0b\nEMJCduS9k595Png2dk+57UGKJWNh5JSSvxmOSyHN9Sjp0RM3IU/Lpvb/CNFc\nzK+WNtDjguwe2JGsFp/SfnifnZansAdEmQ0bKakqAUm8QOZutIvIRA2ugRgV\n2NGOaW5/gAUmOLYK5OOLWvSCEcFD2O5pThwpDW8MVRyHVrehmoxngDICisc5\n0CJymhva18N6q2Ii2vsKRaKO8iuh6mPRcbdTRJq0o+aDljkEwpwjoegevxcH\n9iMczIstGV9OcqPjlIx84Tf4n896YhHAHeBpZv5CBPqRoRpyL3T+6uDOSuJj\n8upuMnsECqmxrJ8VBjmpODZ5VjUqmLJoTJWKXh+PagYWADHxCi5OglJyCVGh\n6to0V6rC3ZH0/DbPC30t91TJjwNBcYyoN/HPUw2Uqb9GFvteMfCue/dRZv3F\nKZZd5Wi2CqfHp1yx6PifUMA3SVCfdyIphZpu8OaRorvzjItFDZBSLd+BjXWm\nkO9aa+ECBGnYz7o7NiDWPIxNseTtMUCbUgumLqdv6rzzgC1OJQ9ChiVNcE7A\nkSlzLf5kDaeqZxnzPV1nIsKDJtpnbxk3ubQ5QYptfUiw/vtXbY5dhV80RKJZ\n8OBw\r\n=uOHG\r\n-----END PGP SIGNATURE-----\r\n"
  },
  "files": [
    "index.js"
  ],
  "gitHead": "f55f91cdda83c20552e431be8fb5ed1daed23ea4",
  "homepage": "https://github.com/isaacs/minipass#readme",
  "keywords": [
    "passthrough",
    "stream"
  ],
  "license": "ISC",
  "main": "index.js",
  "maintainers": [
    {
      "name": "adam_baldwin",
      "email": "evilpacket@gmail.com"
    },
    {
      "name": "ahmadnassri",
      "email": "ahmad@ahmadnassri.com"
    },
    {
      "name": "annekimsey",
      "email": "anne@npmjs.com"
    },
    {
      "name": "billatnpm",
      "email": "billatnpm@gmail.com"
    },
    {
      "name": "claudiahdz",
      "email": "cghr1990@gmail.com"
    },
    {
      "name": "darcyclarke",
      "email": "darcy@darcyclarke.me"
    },
    {
      "name": "isaacs",
      "email": "i@izs.me"
    },
    {
      "name": "mikemimik",
      "email": "mike@mikecorp.ca"
    },
    {
      "name": "ruyadorno",
      "email": "ruyadorno@hotmail.com"
    }
  ],
  "name": "minipass",
  "optionalDependencies": {},
  "readme": "# minipass\n\nA _very_ minimal implementation of a [PassThrough\nstream](https://nodejs.org/api/stream.html#stream_class_stream_passthrough)\n\n[It's very\nfast](https://docs.google.com/spreadsheets/d/1oObKSrVwLX_7Ut4Z6g3fZW-AX1j1-k6w-cDsrkaSbHM/edit#gid=0)\nfor objects, strings, and buffers.\n\nSupports pipe()ing (including multi-pipe() and backpressure\ntransmission), buffering data until either a `data` event handler or\n`pipe()` is added (so you don't lose the first chunk), and most other\ncases where PassThrough is a good idea.\n\nThere is a `read()` method, but it's much more efficient to consume\ndata from this stream via `'data'` events or by calling `pipe()` into\nsome other stream.  Calling `read()` requires the buffer to be\nflattened in some cases, which requires copying memory.\n\nThere is also no `unpipe()` method.  Once you start piping, there is\nno stopping it!\n\nIf you set `objectMode: true` in the options, then whatever is written\nwill be emitted.  Otherwise, it'll do a minimal amount of Buffer\ncopying to ensure proper Streams semantics when `read(n)` is called.\n\nThis is not a `through` or `through2` stream.  It doesn't transform\nthe data, it just passes it right through.  If you want to transform\nthe data, extend the class, and override the `write()` method.  Once\nyou're done transforming the data however you want, call\n`super.write()` with the transform output.\n\nFor some examples of streams that extend MiniPass in various ways, check\nout:\n\n- [minizlib](http://npm.im/minizlib)\n- [fs-minipass](http://npm.im/fs-minipass)\n- [tar](http://npm.im/tar)\n- [minipass-collect](http://npm.im/minipass-collect)\n- [minipass-flush](http://npm.im/minipass-flush)\n- [minipass-pipeline](http://npm.im/minipass-pipeline)\n- [tap](http://npm.im/tap)\n- [tap-parser](http://npm.im/tap)\n- [treport](http://npm.im/tap)\n\n## Differences from Node.js Streams\n\nThere are several things that make Minipass streams different from (and in\nsome ways superior to) Node.js core streams.\n\n### Timing\n\nMinipass streams are designed to support synchronous use-cases.  Thus, data\nis emitted as soon as it is available, always.  It is buffered until read,\nbut no longer.  Another way to look at it is that Minipass streams are\nexactly as synchronous as the logic that writes into them.\n\nThis can be surprising if your code relies on `PassThrough.write()` always\nproviding data on the next tick rather than the current one, or being able\nto call `resume()` and not have the entire buffer disappear immediately.\n\nHowever, without this synchronicity guarantee, there would be no way for\nMinipass to achieve the speeds it does, or support the synchronous use\ncases that it does.  Simply put, waiting takes time.\n\nThis non-deferring approach makes Minipass streams much easier to reason\nabout, especially in the context of Promises and other flow-control\nmechanisms.\n\n### No High/Low Water Marks\n\nNode.js core streams will optimistically fill up a buffer, returning `true`\non all writes until the limit is hit, even if the data has nowhere to go.\nThen, they will not attempt to draw more data in until the buffer size dips\nbelow a minimum value.\n\nMinipass streams are much simpler.  The `write()` method will return `true`\nif the data has somewhere to go (which is to say, given the timing\nguarantees, that the data is already there by the time `write()` returns).\n\nIf the data has nowhere to go, then `write()` returns false, and the data\nsits in a buffer, to be drained out immediately as soon as anyone consumes\nit.\n\n### Emit `end` When Asked\n\nIf you do `stream.on('end', someFunction)`, and the stream has already\nemitted `end`, then it will emit it again.\n\nTo prevent calling handlers multiple times who would not expect multiple\nends to occur, all listeners are removed from the `'end'` event whenever it\nis emitted.\n\n## USAGE\n\n```js\nconst MiniPass = require('minipass')\nconst mp = new MiniPass(options) // optional: { encoding }\nmp.write('foo')\nmp.pipe(someOtherStream)\nmp.end('bar')\n```\n\n### simple \"are you done yet\" promise\n\n```js\nmp.promise().then(() => {\n  // stream is finished\n}, er => {\n  // stream emitted an error\n})\n```\n\n### collecting\n\n```js\nmp.collect().then(all => {\n  // all is an array of all the data emitted\n  // encoding is supported in this case, so\n  // so the result will be a collection of strings if\n  // an encoding is specified, or buffers/objects if not.\n  //\n  // In an async function, you may do\n  // const data = await stream.collect()\n})\n```\n\n### collecting into a single blob\n\nThis is a bit slower because it concatenates the data into one chunk for\nyou, but if you're going to do it yourself anyway, it's convenient this\nway:\n\n```js\nmp.concat().then(onebigchunk => {\n  // onebigchunk is a string if the stream\n  // had an encoding set, or a buffer otherwise.\n})\n```\n\n### iteration\n\nYou can iterate over streams synchronously or asynchronously in\nplatforms that support it.\n\nSynchronous iteration will end when the currently available data is\nconsumed, even if the `end` event has not been reached.  In string and\nbuffer mode, the data is concatenated, so unless multiple writes are\noccurring in the same tick as the `read()`, sync iteration loops will\ngenerally only have a single iteration.\n\nTo consume chunks in this way exactly as they have been written, with\nno flattening, create the stream with the `{ objectMode: true }`\noption.\n\n```js\nconst mp = new Minipass({ objectMode: true })\nmp.write('a')\nmp.write('b')\nfor (let letter of mp) {\n  console.log(letter) // a, b\n}\nmp.write('c')\nmp.write('d')\nfor (let letter of mp) {\n  console.log(letter) // c, d\n}\nmp.write('e')\nmp.end()\nfor (let letter of mp) {\n  console.log(letter) // e\n}\nfor (let letter of mp) {\n  console.log(letter) // nothing\n}\n```\n\nAsynchronous iteration will continue until the end event is reached,\nconsuming all of the data.\n\n```js\nconst mp = new Minipass({ encoding: 'utf8' })\n\n// some source of some data\nlet i = 5\nconst inter = setInterval(() => {\n  if (i --> 0)\n    mp.write(Buffer.from('foo\\n', 'utf8'))\n  else {\n    mp.end()\n    clearInterval(inter)\n  }\n}, 100)\n\n// consume the data with asynchronous iteration\nasync function consume () {\n  for await (let chunk of mp) {\n    console.log(chunk)\n  }\n  return 'ok'\n}\n\nconsume().then(res => console.log(res))\n// logs `foo\\n` 5 times, and then `ok`\n```\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/isaacs/minipass.git"
  },
  "scripts": {
    "postpublish": "git push origin --follow-tags",
    "postversion": "npm publish",
    "preversion": "npm test",
    "test": "tap test/*.js --100"
  },
  "version": "2.6.0"
}
